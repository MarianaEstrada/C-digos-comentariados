# Códigos comentariados

## LED ON 

Lo que hace este progrma es encender el LED ubicado en el pin PA5

~~~

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

/*************************************************
* function declarations
*************************************************/
int main(void);

int main(void)
{

	// Se habilita el banco A 
	RCC->AHB2ENR = 0x00000001;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

	//Envia un alto lógico (1) al pin 5 del puerto A
	GPIOA->ODR |= 0x0020;	

	while(1)
	{
		
	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}

~~~~


## Button LED

Lo que hace este programa es que cuando se detecta que se oprimió el pulsador ubicado en el pin PC13, el LED ubicado en PA5 se apaga.

~~~
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

// Se define una variable LEDDELAY de 1seg
#define LEDDELAY    1000000

/*************************************************
* function declarations
*************************************************/
int main(void);

int main(void)
{
	// Se habilita el banco A y el banco C 
	RCC->AHB2ENR = 0x00000005;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

   // Se configura el pin PC13
	GPIOC->MODER &= 0xFFFFFFFF;		// Se limpian los bits 26 y 27 correspondientes a PC13  donde esta el pulsador
	GPIOC->MODER &= 0xF3FFFFFF;		// Se pone 00 en los bits 26 y 27 para que se configure como una ENTRADA

	while(1)
	{
  
  //Detecta si se oprimio el botón, si esto ocurre el LED se apaga.
		if(GPIOC->IDR == (uint16_t)(1 << 13)) {
    // Se enciende el LED
			GPIOA->ODR |= 0x0020;	
		} else {
    // Se apaga el LED
			GPIOA->ODR &= 0x0000;   
		}
	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}
~~~

## LED blink

Este programa hace que el LED ubicado en PA5 titile cada 1seg.

~~~
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

// Se define una variable LEDDELAY de 1seg
#define LEDDELAY    1000000

/*************************************************
* function declarations
*************************************************/
int main(void);
//Se activa la función delay la cual tendrá como entrada una variable volatile de 32 bits.
void delay(volatile uint32_t s);

int main(void)
{

	// Se habilita el banco A 
	RCC->AHB2ENR = 0x00000001;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

	//Envia un alto lógico (1) al pin 5 del puerto A
	GPIOA->ODR |= 0x0020;			

	while(1)
	{
	
	// Se llama la función delay y va a tener como entrada la variable LEDDELAY que corresponde a 1seg.
		delay(LEDDELAY);
	// La función XOR permite que varie de 0 a 1 
		GPIOA->ODR ^= (1 << 5);  // Toggle LED
	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}

// Se define la función delay, la cual es una función de retraso.
void delay(volatile uint32_t s)
{
    for(s; s>0; s--){
        // Do nothing
    }
}
~~~

## Interrupción externa 

~~~
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

// create a led delay. Just a rough estimate
// for one second delay
#define LEDDELAY    1000

/*************************************************
* function declarations
*************************************************/
int main(void);

/*************************************************
* external interrupt handler
*************************************************/
void EXTI15_10_IRQHandler(void)
{
	//Check if the interrupt came from exti13
	if(EXTI->PR1 & (1 <<13)) {
		GPIOA->ODR ^= (uint16_t)(1 << 5);

		// Clear pending bit
		EXTI->PR1 = 0x00002000;
	}
}

int main(void)
{
	// Enable GPIOA and GPIOC Peripheral Clock (bit 0 and 2 in AHB2ENR register)
	RCC->AHB2ENR = 0x00000005;

	// Make GPIOA Pin5 as output pin (bits 1:0 in MODER register)
	GPIOA->MODER &= 0xABFFFFFF;		// Clear bits 11, 10 for P5
	GPIOA->MODER &= 0xFFFFF7FF;		// Write 01 to bits 11, 10 for P5

	// Make GPIOD Pin13 as input pin (bits 27:26 in MODER register)
	GPIOC->MODER &= 0xFFFFFFFF;		// Clear bits 27, 26 for P13
	GPIOC->MODER &= 0xF3FFFFFF;		// Write 00 to bits 27, 26 for P13

	// enable SYSCFG clock (APB2ENR: bit 0)
	RCC->APB2ENR = 0x00000001;

	/* tie push button at PC13 to EXTI4 */
	// EXTI4 can be configured for each GPIO module.
	// EXTICR1: 0b XXXX XXXX XXXX 0000
	//             pin3 pin2 pin1 pin0
	//
	// Writing a 0b0010 to pin13 location ties PC13 to EXT4
	SYSCFG->EXTICR[3] |= 0x0020;	// Write 0002 to map PC13 to EXTI4
	// Choose either rising edge trigger (RTSR1) or falling edge trigger (FTSR1)
	EXTI->RTSR1 |= 0x00002000;	// Enable rising edge trigger on EXTI4
	// Mask the used external interrupt numbers.
	EXTI->IMR1 |= 0x00002000;	// Mask EXTI4
	// Set Priority for each interrupt request
	NVIC->IP[EXTI15_10_IRQn] = 0x10;	// Priority level 1
	// enable EXT0 IRQ from NVIC
	NVIC_EnableIRQ(EXTI15_10_IRQn);



	while(1)
	{

	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}
~~~






