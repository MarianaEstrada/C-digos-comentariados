# Códigos comentariados

## LED ON 

Este progrma enciende el LED ubicado en el pin PA5

~~~

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

/*************************************************
* function declarations
*************************************************/
int main(void);

int main(void)
{

	// Se habilita el banco A 
	RCC->AHB2ENR = 0x00000001;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

	//Envia un alto lógico (1) al pin 5 del puerto A
	GPIOA->ODR |= 0x0020;	

	while(1)
	{
		
	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}

~~~~


## Button LED

Este programa  detecta cuando se oprimió el pulsador ubicado en el pin PC13 y apaga el LED ubicado en PA5 .

~~~
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

// Se define una variable LEDDELAY de 1seg
#define LEDDELAY    1000000

/*************************************************
* function declarations
*************************************************/
int main(void);

int main(void)
{
	// Se habilita el banco A y el banco C 
	RCC->AHB2ENR = 0x00000005;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

   // Se configura el pin PC13
	GPIOC->MODER &= 0xFFFFFFFF;		// Se limpian los bits 26 y 27 correspondientes a PC13  donde esta el pulsador
	GPIOC->MODER &= 0xF3FFFFFF;		// Se pone 00 en los bits 26 y 27 para que se configure como una ENTRADA

	while(1)
	{
  
  //Detecta si se oprimio el botón, si esto ocurre el LED se apaga.
		if(GPIOC->IDR == (uint16_t)(1 << 13)) {
    // Se enciende el LED
			GPIOA->ODR |= 0x0020;	
		} else {
    // Se apaga el LED
			GPIOA->ODR &= 0x0000;   
		}
	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}
~~~

## LED blink

Este programa hace que el LED ubicado en PA5 titile cada 1seg.

~~~
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

// Se define una variable LEDDELAY de 1seg
#define LEDDELAY    1000000

/*************************************************
* function declarations
*************************************************/
int main(void);
//Se activa la función delay la cual tendrá como entrada una variable volatile de 32 bits.
void delay(volatile uint32_t s);

int main(void)
{

	// Se habilita el banco A 
	RCC->AHB2ENR = 0x00000001;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

	//Envia un alto lógico (1) al pin 5 del puerto A
	GPIOA->ODR |= 0x0020;			

	while(1)
	{
	
	// Se llama la función delay y va a tener como entrada la variable LEDDELAY que corresponde a 1seg.
		delay(LEDDELAY);
	// La función XOR permite que varie de 0 a 1 
		GPIOA->ODR ^= (1 << 5);  // Toggle LED
	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}

// Se define la función delay, la cual es una función de retraso.
void delay(volatile uint32_t s)
{
    for(s; s>0; s--){
        // Do nothing
    }
}
~~~

## Interrupción externa 

Este progama hace que el LED ubicado en el pin PA5 se encienda o se apague, cada vez que se oprime el botón ubicado en PC13 utilizando interrupciones externas.

~~~
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"

// Se define una variable LEDDELAY con un valor de 1000
#define LEDDELAY    1000

/*************************************************
* function declarations
*************************************************/
int main(void);

/*************************************************
* external interrupt handler
*************************************************/
void EXTI15_10_IRQHandler(void)
{
	//Check if the interrupt came from exti13
	if(EXTI->PR1 & (1 <<13)) {
		GPIOA->ODR ^= (uint16_t)(1 << 5);

		// Clear pending bit
		EXTI->PR1 = 0x00002000;
	}
}

int main(void)
{
	// Se habilita el banco A y C 
	RCC->AHB2ENR = 0x00000005;

	// Se configura el pin PA5
	GPIOA->MODER &= 0xABFFFFFF;		// Se limpian los bits 10 y 11 correspondientes a P5 donde esta el LED
	GPIOA->MODER &= 0xFFFFF7FF;		// Se pone 01 en los bits 10 y 11 para que se configure como una salida 

 	  // Se configura el pin PC13
	GPIOC->MODER &= 0xFFFFFFFF;		// Se limpian los bits 26 y 27 correspondientes a PC13  donde esta el pulsador
	GPIOC->MODER &= 0xF3FFFFFF;		// Se pone 00 en los bits 26 y 27 para que se configure como una ENTRADA
	
	// Para que la interrupción empiece a trabajar es necesario activar el SYSCFG 
	RCC->APB2ENR = 0x00000001; // Se habilita el bit 0 

	/* tie push button at PC13 to EXTI4 */
	// EXTI4 can be configured for each GPIO module.
	// EXTICR1: 0b XXXX XXXX XXXX 0000
	//             pin3 pin2 pin1 pin0
	//
	// Se va le va a decir al SYSCFG que se va trabajar una interrupción externa.
	//Se habilita la interrupción 3 porque es la que corresponde a PC13
	SYSCFG->EXTICR[3] |= 0x0020;	//Se pone 0010 de los bits de 4 a 7 
	//Se configura que la interrupción va a funcionar con flancos de subida
	EXTI->RTSR1 |= 0x00002000;	// Se pone un 1 en el bit 13
	// Se hace un enmascaramiento de la interrupción 
	EXTI->IMR1 |= 0x00002000;	
	// Se le da una prioridad a la interrupción nivel 1
	// EXTI15_10 es el nombre de la prioridad.
	NVIC->IP[EXTI15_10_IRQn] = 0x10; // El 00 y el 01 no se pueden usar porque pertenece al reset y donde inicia la memoria.
	// Se habilita la interrupción.
	NVIC_EnableIRQ(EXTI15_10_IRQn);



	while(1)
	{

	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}
~~~






